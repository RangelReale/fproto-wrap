# fproto-gowrap

[![GoDoc](https://godoc.org/github.com/RangelReale/fproto-wrap/gowrap?status.svg)](https://godoc.org/github.com/RangelReale/fproto-wrap/gowrap)

Package for generating wrappers to the default Go protobuf generated structs and interfaces. 

### abstract

The Go generated protobuf source code isn't very developer-friendly. Well-known types that could use standard Go types without too much effort returns structs that are hard to use and requires a lot of manual parsing.

This package creates objects that wrap the generated Go types into easier to use ones, and converts between them automatically.

Type converters can be plugged in to support converting any type, like UUIDs or your application internal types.
Included are plugins for time.Time, time.Duration, and UUID.

Customizers can be used to inject your own generated code into any file, using the same tools that the library uses for its processing.
Included is a customizer that adds json tags to all struct fields.

Service types can be generated using plugins, and a gRPC one is provided.

The gRPC service wrapper creates new structs with the same name as the original ones that uses the new wrapped types, and automatically calls the original Go generated ones, autmatically converting the structs between the formats.

The intended use of this package is that you create your own gowrap executable with the plugins you need, and call it on your application.
No default executable is provided.

### example

Given this proto file:

```protobuf
syntax = "proto3";
package gw_sample;
option go_package = "gwsample/core";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "github.com/RangelReale/fproto-wrap/uuid.proto";

message User {
    fproto_wrap.UUID id = 1;
    string name = 2;
    string email = 3;
    google.protobuf.Timestamp dt_created = 4;

    message Address {
        enum AddressType {
            HOME = 0;
            MOBILE = 1;
            WORK = 2;
        }

        AddressType address_type = 20;
        string address = 21;
    }

    Address address = 5;
}

service UserSvc {
    rpc List(google.protobuf.Empty) returns (UserListResponse);
    rpc Get(fproto_wrap.UUID) returns (User);
    rpc Add(User) returns (fproto_wrap.UUID);
    rpc Modify(User) returns (google.protobuf.Empty);
    rpc Delete(fproto_wrap.UUID) returns (google.protobuf.Empty);
}

message UserListResponse {
    repeated User list = 1;
}
```

The standard Go proto generator generates this (file ending omitted for brevity):

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pt1/kernel/core/sample.proto

package core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf2 "github.com/golang/protobuf/ptypes/empty"
import gwproto "github.com/RangelReale/fproto-wrap/gowrap/gwproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type User_Address_AddressType int32

const (
	User_Address_HOME   User_Address_AddressType = 0
	User_Address_MOBILE User_Address_AddressType = 1
	User_Address_WORK   User_Address_AddressType = 2
)

var User_Address_AddressType_name = map[int32]string{
	0: "HOME",
	1: "MOBILE",
	2: "WORK",
}
var User_Address_AddressType_value = map[string]int32{
	"HOME":   0,
	"MOBILE": 1,
	"WORK":   2,
}

func (x User_Address_AddressType) String() string {
	return proto.EnumName(User_Address_AddressType_name, int32(x))
}
func (User_Address_AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 0, 0}
}

type User struct {
	Id        *gwproto.UUID           `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name      string                      `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Email     string                      `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
	DtCreated *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=dt_created,json=dtCreated" json:"dt_created,omitempty"`
	Address   *User_Address               `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *User) GetId() *gwproto.UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetDtCreated() *google_protobuf1.Timestamp {
	if m != nil {
		return m.DtCreated
	}
	return nil
}

func (m *User) GetAddress() *User_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type User_Address struct {
	AddressType User_Address_AddressType `protobuf:"varint,20,opt,name=address_type,json=addressType,enum=gw_sample.User_Address_AddressType" json:"address_type,omitempty"`
	Address     string                   `protobuf:"bytes,21,opt,name=address" json:"address,omitempty"`
}

func (m *User_Address) Reset()                    { *m = User_Address{} }
func (m *User_Address) String() string            { return proto.CompactTextString(m) }
func (*User_Address) ProtoMessage()               {}
func (*User_Address) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *User_Address) GetAddressType() User_Address_AddressType {
	if m != nil {
		return m.AddressType
	}
	return User_Address_HOME
}

func (m *User_Address) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type UserListResponse struct {
	List []*User `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *UserListResponse) Reset()                    { *m = UserListResponse{} }
func (m *UserListResponse) String() string            { return proto.CompactTextString(m) }
func (*UserListResponse) ProtoMessage()               {}
func (*UserListResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *UserListResponse) GetList() []*User {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*User)(nil), "gw_sample.User")
	proto.RegisterType((*User_Address)(nil), "gw_sample.User.Address")
	proto.RegisterType((*UserListResponse)(nil), "gw_sample.UserListResponse")
	proto.RegisterEnum("gw_sample.User_Address_AddressType", User_Address_AddressType_name, User_Address_AddressType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UserSvc service

type UserSvcClient interface {
	List(ctx context.Context, in *google_protobuf2.Empty, opts ...grpc.CallOption) (*UserListResponse, error)
	Get(ctx context.Context, in *gwproto.UUID, opts ...grpc.CallOption) (*User, error)
	Add(ctx context.Context, in *User, opts ...grpc.CallOption) (*gwproto.UUID, error)
	Modify(ctx context.Context, in *User, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)
	Delete(ctx context.Context, in *gwproto.UUID, opts ...grpc.CallOption) (*google_protobuf2.Empty, error)
}

type userSvcClient struct {
	cc *grpc.ClientConn
}

func NewUserSvcClient(cc *grpc.ClientConn) UserSvcClient {
	return &userSvcClient{cc}
}

func (c *userSvcClient) List(ctx context.Context, in *google_protobuf2.Empty, opts ...grpc.CallOption) (*UserListResponse, error) {
	out := new(UserListResponse)
	err := grpc.Invoke(ctx, "/gw_sample.UserSvc/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userSvcClient) Get(ctx context.Context, in *gwproto.UUID, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/gw_sample.UserSvc/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userSvcClient) Add(ctx context.Context, in *User, opts ...grpc.CallOption) (*gwproto.UUID, error) {
	out := new(gwproto.UUID)
	err := grpc.Invoke(ctx, "/gw_sample.UserSvc/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userSvcClient) Modify(ctx context.Context, in *User, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {
	out := new(google_protobuf2.Empty)
	err := grpc.Invoke(ctx, "/gw_sample.UserSvc/Modify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userSvcClient) Delete(ctx context.Context, in *gwproto.UUID, opts ...grpc.CallOption) (*google_protobuf2.Empty, error) {
	out := new(google_protobuf2.Empty)
	err := grpc.Invoke(ctx, "/gw_sample.UserSvc/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserSvc service

type UserSvcServer interface {
	List(context.Context, *google_protobuf2.Empty) (*UserListResponse, error)
	Get(context.Context, *gwproto.UUID) (*User, error)
	Add(context.Context, *User) (*gwproto.UUID, error)
	Modify(context.Context, *User) (*google_protobuf2.Empty, error)
	Delete(context.Context, *gwproto.UUID) (*google_protobuf2.Empty, error)
}

func RegisterUserSvcServer(s *grpc.Server, srv UserSvcServer) {
	s.RegisterService(&_UserSvc_serviceDesc, srv)
}
```


The generator source code:

```go
package main

import (
	"log"
	
	"github.com/RangelReale/fproto-wrap/gowrap"
	"github.com/RangelReale/fproto-wrap/gowrap/cz/jsontag"
	"github.com/RangelReale/fproto-wrap/gowrap/tc/time"
	"github.com/RangelReale/fproto-wrap/gowrap/tc/uuid"
	"github.com/RangelReale/fdep"
)

func main() {
	// Creates the proto file files and dependencies parser
	parsedep := fdep.NewDep()
	
	// Add the google.protobuf files
	err := parsedep.AddPath(`C:\protoc-3.5.1-win32\include`, fdep.DepType_Imported)
	if err != nil {
		log.Fatal(err)
	}
	
	// Add the fproto-wrap types
	err = parsedep.AddPathWithRoot("github.com/RangelReale/fproto-wrap", `C:\go\src\github.com\RangelReale\fproto-wrap`, fdep.DepType_Imported)
	if err != nil {
		log.Fatal(err)
	}

	// Add your application source code
	err = parsedep.AddPathWithRoot("gwsample", `c:\app\src\gwsample\proto`, fdep.DepType_Own)
	if err != nil {
		log.Fatal(err)
	}
	
	// Creates the wrapper class
	w := fproto_gowrap.NewWrapper(parsedep)
	
	// Add the UUID and time.Time type converters
	w.TypeConvs = append(w.TypeConvs,
		&uuid.TypeConverter_UUID{},
		&time.TypeConverter_Time{},
	)
	
	// Add the JSON tag customizer (adds JSON tags to struct fields)
	w.Customizers = append(w.Customizers,
		&jsontag.Customizer_JSONTag{},
	)
	
	// Generates services in gRPC format
	w.ServiceGen = &fproto_gowrap.ServiceGen_gRPC{}

	// Generates the go wrapper files in this path
	err = w.GenerateFiles(`c:\app\src\gwsample\src`)
	if err != nil {
		log.Fatal(err)
	}
}

```

Outputs this easier-to-use Go file (sample.gwpb.go):

```go
// Code generated by fproto-gowrap2. DO NOT EDIT.
// source file: pt1/kernel/core/sample.proto
package core

import (
	core "gwsample/core"
	uuid "github.com/RangelReale/go.uuid"
	time "time"
	pb_types "github.com/golang/protobuf/ptypes"
	gwproto "github.com/RangelReale/fproto-wrap/gowrap/gwproto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	google_protobuf "github.com/golang/protobuf/ptypes/empty"
)

//
// message User
// gotype core.User
// gowraptype User
//
type User struct {
	Id        uuid.UUID     `json:"id,omitempty"`
	Name      string        `json:"name,omitempty"`
	Email     string        `json:"email,omitempty"`
	DtCreated time.Time     `json:"dt_created,omitempty"`
	Address   *User_Address `json:"address,omitempty"`
}

func User_Import(s *core.User) (*User, error) {
	var err error
	ret := &User{}
	if s.Id != nil {
		ret.Id, err = uuid.FromString(s.Id.Value)
	}
	if err != nil {
		return &User{}, err
	}
	ret.Name = s.Name
	ret.Email = s.Email
	if s.DtCreated != nil {
		ret.DtCreated, err = pb_types.Timestamp(s.DtCreated)
	}
	if err != nil {
		return &User{}, err
	}
	ret.Address, err = User_Address_Import(s.Address)
	if err != nil {
		return &User{}, err
	}
	return ret, err
}

func (m *User) Export() (*core.User, error) {
	var err error
	ret := &core.User{}
	ret.Id = &gwproto.UUID{}
	ret.Id.Value = m.Id.String()
	ret.Name = m.Name
	ret.Email = m.Email
	ret.DtCreated, err = pb_types.TimestampProto(m.DtCreated)
	if err != nil {
		return &core.User{}, err
	}
	ret.Address, err = m.Address.Export()
	if err != nil {
		return &core.User{}, err
	}
	return ret, err
}

//
// message User.Address
// gotype core.User_Address
// gowraptype User_Address
//
type User_Address struct {
	AddressType User_Address_AddressType `json:"address_type,omitempty"`
	Address     string                   `json:"address,omitempty"`
}

func User_Address_Import(s *core.User_Address) (*User_Address, error) {
	var err error
	ret := &User_Address{}
	ret.AddressType = s.AddressType
	ret.Address = s.Address
	return ret, err
}

func (m *User_Address) Export() (*core.User_Address, error) {
	var err error
	ret := &core.User_Address{}
	ret.AddressType = m.AddressType
	ret.Address = m.Address
	return ret, err
}

//
// enum User.Address.AddressType
// gotype core.User_Address_AddressType
// gowraptype User_Address_AddressType
//
type User_Address_AddressType = core.User_Address_AddressType

const (
	User_Address_HOME   User_Address_AddressType = core.User_Address_HOME
	User_Address_MOBILE User_Address_AddressType = core.User_Address_MOBILE
	User_Address_WORK   User_Address_AddressType = core.User_Address_WORK
)

var User_Address_AddressType_name = core.User_Address_AddressType_name
var User_Address_AddressType_value = core.User_Address_AddressType_value

//
// message UserListResponse
// gotype core.UserListResponse
// gowraptype UserListResponse
//
type UserListResponse struct {
	List []*User `json:"list,omitempty"`
}

func UserListResponse_Import(s *core.UserListResponse) (*UserListResponse, error) {
	var err error
	ret := &UserListResponse{}
	for _, ms := range s.List {
		var msi *User
		msi, err = User_Import(ms)
		if err != nil {
			return &UserListResponse{}, err
		}
		ret.List = append(ret.List, msi)
	}
	return ret, err
}

func (m *UserListResponse) Export() (*core.UserListResponse, error) {
	var err error
	ret := &core.UserListResponse{}
	for _, ms := range m.List {
		var msi *core.User
		msi, err = ms.Export()
		if err != nil {
			return &core.UserListResponse{}, err
		}
		ret.List = append(ret.List, msi)
	}
	return ret, err
}

type UserSvcClient interface {
	List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*UserListResponse, error)
	Get(ctx context.Context, in uuid.UUID, opts ...grpc.CallOption) (*User, error)
	Add(ctx context.Context, in *User, opts ...grpc.CallOption) (uuid.UUID, error)
	Modify(ctx context.Context, in *User, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Delete(ctx context.Context, in uuid.UUID, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type wrapUserSvcClient struct {
	cli core.UserSvcClient
}

func NewUserSvcClient(cc *grpc.ClientConn) UserSvcClient {
	w := &wrapUserSvcClient{cli: core.NewUserSvcClient(cc)}
	return w
}

func (w *wrapUserSvcClient) List(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*UserListResponse, error) {
	var err error

	var wreq *google_protobuf.Empty
	wreq = in

	resp, err := w.cli.List(ctx, wreq)
	if err != nil {
		return &UserListResponse{}, err
	}

	var wresp *UserListResponse
	wresp, err = UserListResponse_Import(resp)
	if err != nil {
		return &UserListResponse{}, err
	}

	return wresp, nil
}

func (w *wrapUserSvcClient) Get(ctx context.Context, in uuid.UUID, opts ...grpc.CallOption) (*User, error) {
	var err error

	var wreq *gwproto.UUID
	wreq = &gwproto.UUID{}
	wreq.Value = in.String()

	resp, err := w.cli.Get(ctx, wreq)
	if err != nil {
		return &User{}, err
	}

	var wresp *User
	wresp, err = User_Import(resp)
	if err != nil {
		return &User{}, err
	}

	return wresp, nil
}

func (w *wrapUserSvcClient) Add(ctx context.Context, in *User, opts ...grpc.CallOption) (uuid.UUID, error) {
	var err error

	var wreq *core.User
	wreq, err = in.Export()
	if err != nil {
		return uuid.UUID{}, err
	}

	resp, err := w.cli.Add(ctx, wreq)
	if err != nil {
		return uuid.UUID{}, err
	}

	var wresp uuid.UUID
	if resp != nil {
		wresp, err = uuid.FromString(resp.Value)
	}
	if err != nil {
		return uuid.UUID{}, err
	}

	return wresp, nil
}

func (w *wrapUserSvcClient) Modify(ctx context.Context, in *User, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	var err error

	var wreq *core.User
	wreq, err = in.Export()
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	resp, err := w.cli.Modify(ctx, wreq)
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	var wresp *google_protobuf.Empty
	wresp = resp

	return wresp, nil
}

func (w *wrapUserSvcClient) Delete(ctx context.Context, in uuid.UUID, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	var err error

	var wreq *gwproto.UUID
	wreq = &gwproto.UUID{}
	wreq.Value = in.String()

	resp, err := w.cli.Delete(ctx, wreq)
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	var wresp *google_protobuf.Empty
	wresp = resp

	return wresp, nil
}

type UserSvcServer interface {
	List(context.Context, *google_protobuf.Empty) (*UserListResponse, error)
	Get(context.Context, uuid.UUID) (*User, error)
	Add(context.Context, *User) (uuid.UUID, error)
	Modify(context.Context, *User) (*google_protobuf.Empty, error)
	Delete(context.Context, uuid.UUID) (*google_protobuf.Empty, error)
}

type wrapUserSvcServer struct {
	srv UserSvcServer
}

func newWrapUserSvcServer(srv UserSvcServer) *wrapUserSvcServer {
	w := &wrapUserSvcServer{srv: srv}
	return w
}

func (w *wrapUserSvcServer) List(ctx context.Context, req *google_protobuf.Empty) (*core.UserListResponse, error) {
	var err error

	var wreq *google_protobuf.Empty
	wreq = req

	resp, err := w.srv.List(ctx, wreq)
	if err != nil {
		return &core.UserListResponse{}, err
	}

	var wresp *core.UserListResponse
	wresp, err = resp.Export()
	if err != nil {
		return &core.UserListResponse{}, err
	}

	return wresp, nil
}

func (w *wrapUserSvcServer) Get(ctx context.Context, req *gwproto.UUID) (*core.User, error) {
	var err error

	var wreq uuid.UUID
	if req != nil {
		wreq, err = uuid.FromString(req.Value)
	}
	if err != nil {
		return &core.User{}, err
	}

	resp, err := w.srv.Get(ctx, wreq)
	if err != nil {
		return &core.User{}, err
	}

	var wresp *core.User
	wresp, err = resp.Export()
	if err != nil {
		return &core.User{}, err
	}

	return wresp, nil
}

func (w *wrapUserSvcServer) Add(ctx context.Context, req *core.User) (*gwproto.UUID, error) {
	var err error

	var wreq *User
	wreq, err = User_Import(req)
	if err != nil {
		return &gwproto.UUID{}, err
	}

	resp, err := w.srv.Add(ctx, wreq)
	if err != nil {
		return &gwproto.UUID{}, err
	}

	var wresp *gwproto.UUID
	wresp = &gwproto.UUID{}
	wresp.Value = resp.String()

	return wresp, nil
}

func (w *wrapUserSvcServer) Modify(ctx context.Context, req *core.User) (*google_protobuf.Empty, error) {
	var err error

	var wreq *User
	wreq, err = User_Import(req)
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	resp, err := w.srv.Modify(ctx, wreq)
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	var wresp *google_protobuf.Empty
	wresp = resp

	return wresp, nil
}

func (w *wrapUserSvcServer) Delete(ctx context.Context, req *gwproto.UUID) (*google_protobuf.Empty, error) {
	var err error

	var wreq uuid.UUID
	if req != nil {
		wreq, err = uuid.FromString(req.Value)
	}
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	resp, err := w.srv.Delete(ctx, wreq)
	if err != nil {
		return &google_protobuf.Empty{}, err
	}

	var wresp *google_protobuf.Empty
	wresp = resp

	return wresp, nil
}

func RegisterUserSvcServer(s *grpc.Server, srv UserSvcServer) {
	core.RegisterUserSvcServer(s, newWrapUserSvcServer(srv))
}
```

### related

 * [https://github.com/RangelReale/fproto](https://github.com/RangelReale/fproto)
    The protobuf file parser used in this package.
	
### author

Rangel Reale (rangelspam@gmail.com)
